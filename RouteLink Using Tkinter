

# routelink_slot_autogen_endp_readonly_linktab_with_gender.py
"""
RouteLink:
- Slot No autogenerated sequentially (alphanumeric using base36) and pre-filled in Create Route dialog.
- No "Route created" messagebox after creating a route.
- Calendar: today highlighted blue; past-date clicks show warning.
- Duplicate-check for same transport/endpoint/time on same date.
- Link Details: ID column removed from display; when opened for a specific route,
  the Drop field is pre-filled with the route's end_point and set readonly.
- Gender (M/F) added to registration and to link records.
- Link Details includes a gender filter (All / Male / Female).
- DB migration logic to add missing gender columns if DB exists.
- All major screens and dialogs are scrollable (horizontal + vertical).
"""

import os
import re
import sqlite3
import hashlib
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime, date
import calendar
import json
import csv
import random
from typing import Optional

# Optional libs
try:
    from PIL import Image, ImageTk
    PIL_AVAILABLE = True
except Exception:
    PIL_AVAILABLE = False

DB = "routelink.db"
LOGO_PATH = "logo.png"
HOL_JSON = "academic_holidays.json"
HOL_CSV = "academic_holidays.csv"


# ---------------- Database / Migration helpers ----------------
def ensure_column(table: str, column: str, col_type: str, default: Optional[str] = None):
    """
    Ensure a column exists in a table; if not, ALTER TABLE ADD COLUMN.
    Note: SQLite's ALTER TABLE only supports adding columns.
    """
    try:
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute(f"PRAGMA table_info({table})")
        cols = [r[1] for r in c.fetchall()]
        if column not in cols:
            sql = f"ALTER TABLE {table} ADD COLUMN {column} {col_type}"
            if default is not None:
                sql += f" DEFAULT {default}"
            c.execute(sql)
            conn.commit()
        conn.close()
    except Exception:
        try:
            conn.close()
        except Exception:
            pass


def init_db():
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            email TEXT UNIQUE,
            password_hash TEXT
        )
    """)
    c.execute("""
        CREATE TABLE IF NOT EXISTS routes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            slot_no TEXT,
            end_point TEXT,
            major_stops TEXT,
            time TEXT,
            transport_type TEXT,
            no_of_people INTEGER DEFAULT 0
        )
    """)
    c.execute("""
        CREATE TABLE IF NOT EXISTS links (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            drop_point TEXT,
            phone TEXT,
            course_year TEXT,
            branch TEXT
        )
    """)
    c.execute("""
        CREATE TABLE IF NOT EXISTS calendar (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            travel_date TEXT,
            route_id INTEGER,
            link_id INTEGER,
            FOREIGN KEY(route_id) REFERENCES routes(id),
            FOREIGN KEY(link_id) REFERENCES links(id)
        )
    """)
    conn.commit()
    conn.close()

    # Migrate: add gender columns if not present
    # users.gender CHAR(1) -> 'M' or 'F' or NULL
    ensure_column("users", "gender", "TEXT")
    # links.gender CHAR(1)
    ensure_column("links", "gender", "TEXT")


def hash_pw(txt: str) -> str:
    return hashlib.sha256(txt.encode()).hexdigest()


def user_exists(email: str) -> bool:
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT id FROM users WHERE email=?", (email,))
    r = c.fetchone()
    conn.close()
    return bool(r)


# ---------------- Holidays loader ----------------
def load_academic_holidays():
    if os.path.exists(HOL_JSON):
        try:
            with open(HOL_JSON, "r", encoding="utf-8") as f:
                data = json.load(f)
            holidays = []
            if isinstance(data, list):
                for item in data:
                    if isinstance(item, str):
                        holidays.append(item)
                    elif isinstance(item, dict) and "date" in item:
                        holidays.append(item["date"])
            return sorted(set(holidays))
        except Exception:
            pass
    if os.path.exists(HOL_CSV):
        try:
            holidays = []
            with open(HOL_CSV, newline='', encoding="utf-8") as f:
                reader = csv.reader(f)
                for row in reader:
                    if not row:
                        continue
                    maybe = row[0].strip()
                    if maybe.lower() == "date":
                        continue
                    holidays.append(maybe)
            return sorted(set(holidays))
        except Exception:
            pass
    return generate_sample_holidays(date.today().year)


def generate_sample_holidays(year: int, seed: int = 123):
    random.seed(seed + year)
#standard holidays
    fixed = [(2025,1, 26), (2025,5, 1), (2025,8, 15), (2025,10, 2), (2025,12, 25)]
#diwali break
    
    for i in range(18,27):
        fixed.append((2025,10,i))
#------------adding christmas
    for i in range(21,32):
        fixed.append((2025,12,i))
    for m in range (2):
        for j in range(1,5):
            fixed.append((2026,1,j))
#------------christmas break added
    holidays = set()
    for y,m, d in fixed:
        try:
            holidays.add(date(y, m, d).isoformat())
        except Exception:
            pass
    while len(holidays) < 10:
        m = random.randint(1, 12)
        d = random.randint(1, calendar.monthrange(year, m)[1])
        holidays.add(date(y, m, d).isoformat())
    return sorted(holidays)



# ---------------- helpers: base36 slot generation ----------------
def to_base36(n: int) -> str:
    """Convert non-negative integer to base36 string (0-9, A-Z)."""
    if n < 0:
        raise ValueError("n must be non-negative")
    digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    if n == 0:
        return "0"
    out = []
    while n:
        n, rem = divmod(n, 36)
        out.append(digits[rem])
    return "".join(reversed(out))


def generate_next_slot_no() -> str:
    """
    Generate a sequential alphanumeric slot number:
    - Find max routes.id, next = max + 1
    - Convert next to base36 and zero-pad to length 4, prefix with 'SL'
    Example: SL0001, SL000A, ...
    """
    try:
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("SELECT MAX(id) FROM routes")
        r = c.fetchone()
        conn.close()
        max_id = int(r[0]) if (r and r[0]) else 0
        seq = max_id + 1
    except Exception:
        seq = 1
    b36 = to_base36(seq).rjust(4, "0")  # pad to at least 4 chars
    return f"SL{b36}"


# ---------------- Tooltip ----------------
class ToolTip:
    def __init__(self, parent):
        self.parent = parent
        self.tipwindow = None

    def show(self, x, y, text):
        self.hide()
        if not text:
            return
        tw = tk.Toplevel(self.parent)
        tw.wm_overrideredirect(True)
        tw.wm_geometry(f"+{x}+{y}")
        lbl = tk.Label(tw, text=text, justify="left", background="#ffffea", relief="solid", borderwidth=1,
                       font=("Arial", 9), padx=6, pady=4)
        lbl.pack()
        self.tipwindow = tw

    def hide(self):
        if self.tipwindow:
            try:
                self.tipwindow.destroy()
            except Exception:
                pass
            self.tipwindow = None


# ---------------- ScrollableFrame (both axes) ----------------
class ScrollableFrame(tk.Frame):
    """
    A frame that adds both vertical and horizontal scrollbars around an internal frame
    accessible as `.inner`. Use `inner` to place your widgets.
    Supports mousewheel vertical scroll and Shift+mousewheel horizontal scroll.
    """
    def __init__(self, parent, width=800, height=500, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.canvas = tk.Canvas(self, borderwidth=0, highlightthickness=0)
        self.vbar = tk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.hbar = tk.Scrollbar(self, orient="horizontal", command=self.canvas.xview)
        self.canvas.configure(yscrollcommand=self.vbar.set, xscrollcommand=self.hbar.set)

        # layout
        self.vbar.pack(side="right", fill="y")
        self.hbar.pack(side="bottom", fill="x")
        self.canvas.pack(side="left", fill="both", expand=True)

        # internal frame
        self.inner = tk.Frame(self.canvas)
        self._inner_id = self.canvas.create_window((0, 0), window=self.inner, anchor="nw")

        # configure resizing
        self.inner.bind("<Configure>", self._on_frame_configure)
        self.canvas.bind("<Configure>", self._on_canvas_configure)

        # mouse wheel bindings
        # Windows / Mac / Linux differences
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel, add="+")
        self.canvas.bind_all("<Shift-MouseWheel>", self._on_shift_mousewheel, add="+")
        # For Linux systems with Button-4/Button-5
        self.canvas.bind_all("<Button-4>", self._on_mousewheel, add="+")
        self.canvas.bind_all("<Button-5>", self._on_mousewheel, add="+")

        # set default size (optional)
        try:
            self.canvas.config(width=width, height=height)
        except Exception:
            pass

    def _on_frame_configure(self, event):
        # update scrollregion
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def _on_canvas_configure(self, event):
        # ensure the inner window width is at least canvas width so internal widgets can expand horizontally;
        # do not force if inner is wider (lets horizontal scroll appear)
        try:
            inner_req_w = self.inner.winfo_reqwidth()
            canvas_w = event.width
            if inner_req_w < canvas_w:
                self.canvas.itemconfigure(self._inner_id, width=canvas_w)
            else:
                self.canvas.itemconfigure(self._inner_id, width=inner_req_w)
        except Exception:
            pass

    def _on_mousewheel(self, event):
        # Vertical scroll; cross-platform handling
        delta = 0
        if hasattr(event, "delta") and event.delta:
            # Windows & Mac: event.delta positive/negative in steps of 120
            delta = -1 * int(event.delta / 120)
        else:
            # Linux: Button-4 = up, Button-5 = down
            if event.num == 4:
                delta = -1
            elif event.num == 5:
                delta = 1
        if delta:
            self.canvas.yview_scroll(delta, "units")

    def _on_shift_mousewheel(self, event):
        # Horizontal scroll when Shift held
        delta = 0
        if hasattr(event, "delta") and event.delta:
            delta = -1 * int(event.delta / 120)
        else:
            if event.num == 4:
                delta = -1
            elif event.num == 5:
                delta = 1
        if delta:
            self.canvas.xview_scroll(delta, "units")


# ---------------- MiniCalendar ----------------
class MiniCalendar(tk.Frame):
    def __init__(self, parent, year=None, month=None, on_select=None, holidays=None, get_counts=None, get_summary=None):
        super().__init__(parent)
        self.on_select = on_select
        self.get_counts = get_counts
        self.get_summary = get_summary
        today = date.today()
        self.year = year or today.year
        self.month = month or today.month
        self.holidays = set(holidays or [])
        self.today = today
        self._build()
        self.tooltip = ToolTip(self)

    def _build(self):
        header = tk.Frame(self)
        header.pack(fill="x", pady=4)
        tk.Button(header, text="<", width=3, command=self.prev_month).pack(side="left")
        self.lbl = tk.Label(header, text=f"{calendar.month_name[self.month]} {self.year}", font=("Arial", 11, "bold"))
        self.lbl.pack(side="left", padx=8)
        tk.Button(header, text=">", width=3, command=self.next_month).pack(side="left")
        days = tk.Frame(self)
        days.pack(fill="x", pady=(6, 0))
        for d in ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]:
            tk.Label(days, text=d, width=8, bg="#dfeff6").pack(side="left", padx=1)
        self.grid_frame = tk.Frame(self)
        self.grid_frame.pack(pady=6)
        self.draw()

    def draw(self):
        for child in self.grid_frame.winfo_children():
            child.destroy()
        cal = calendar.Calendar(firstweekday=0)
        for week in cal.monthdayscalendar(self.year, self.month):
            row = tk.Frame(self.grid_frame)
            row.pack()
            for day in week:
                if day == 0:
                    tk.Label(row, text="", width=8, height=3, relief="solid", borderwidth=1, bg="#f0f0f0").pack(side="left", padx=1, pady=1)
                else:
                    iso = date(self.year, self.month, day).isoformat()
                    is_hol = iso in self.holidays
                    count = 0
                    try:
                        if callable(self.get_counts):
                            count = int(self.get_counts(iso) or 0)
                    except Exception:
                        count = 0

                    if is_hol:
                        line2 = "â˜… Holiday"
                    elif count:
                        line2 = f"{count} joined"
                    else:
                        line2 = ""

                    txt = f"{day}\n{line2}" if line2 else f"{day}"

                    # style: today filled blue; holidays pale red; others white
                    if iso == self.today.isoformat():
                        bg = "#4a90e2"
                        fg = "white"
                        activebg = bg
                        activefg = fg
                    elif is_hol:
                        bg = "#ffecec"
                        fg = "#b33"
                        activebg = bg
                        activefg = fg
                    else:
                        bg = "#ffffff"
                        fg = "#000000"
                        activebg = "#f0f8ff"
                        activefg = fg

                    btn = tk.Button(row,
                                    text=txt,
                                    width=8,
                                    height=3,
                                    bg=bg,
                                    fg=fg,
                                    activebackground=activebg,
                                    activeforeground=activefg,
                                    relief="solid",
                                    borderwidth=1,
                                    command=lambda d=day: self._on_click(d))
                    btn.pack(side="left", padx=1, pady=1)
                    btn.bind("<Enter>", lambda ev, iso=iso: self._on_hover_enter(ev, iso))
                    btn.bind("<Leave>", lambda ev: self._on_hover_leave(ev))

    def _on_click(self, day):
        iso = date(self.year, self.month, day).isoformat()
        if callable(self.on_select):
            self.on_select(iso)

    def _on_hover_enter(self, event, iso):
        summary = ""
        try:
            if callable(self.get_summary):
                summary = self.get_summary(iso) or ""
        except Exception:
            summary = ""
        if not summary:
            is_hol = iso in self.holidays
            count = 0
            try:
                if callable(self.get_counts):
                    count = int(self.get_counts(iso) or 0)
            except Exception:
                count = 0
            parts = []
            if is_hol:
                parts.append("Holiday")
            if count:
                parts.append(f"{count} joined")
            summary = "\n".join(parts) if parts else "No scheduled routes"
        x = self.winfo_pointerx() + 12
        y = self.winfo_pointery() + 12
        self.tooltip.show(x, y, summary)

    def _on_hover_leave(self, event):
        self.tooltip.hide()

    def prev_month(self):
        if self.month == 1:
            self.month = 12
            self.year -= 1
        else:
            self.month -= 1
        self.lbl.config(text=f"{calendar.month_name[self.month]} {self.year}")
        self.draw()

    def next_month(self):
        if self.month == 12:
            self.month = 1
            self.year += 1
        else:
            self.month += 1
        self.lbl.config(text=f"{calendar.month_name[self.month]} {self.year}")
        self.draw()

    def update_holidays(self, holidays):
        self.holidays = set(holidays or [])
        self.draw()

    def update_counts_source(self, get_counts):
        self.get_counts = get_counts
        self.draw()

    def update_summary_source(self, get_summary):
        self.get_summary = get_summary
        self.draw()


# ---------------- Main App ----------------
class RouteLinkApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("RouteLink â€” Every Link Counts, Every Route Matters")
        self.geometry("1000x720")
        self.minsize(800, 560)
        self.configure(bg="#f3fbff")

        # logo
        self.logo_photo = None
        if PIL_AVAILABLE and os.path.exists(LOGO_PATH):
            try:
                img = Image.open(LOGO_PATH)
                img.thumbnail((110, 110), Image.LANCZOS)
                self.logo_photo = ImageTk.PhotoImage(img)
            except Exception:
                self.logo_photo = None

        # header
        top = tk.Frame(self, bg="#f3fbff")
        top.pack(fill="x", pady=(10, 0))
        if self.logo_photo:
            tk.Label(top, image=self.logo_photo, bg="#f3fbff").pack(side="left", padx=(14, 12))
        else:
            tk.Label(top, text="ROUTELINK", font=("Helvetica", 26, "bold"), fg="#0b5878", bg="#f3fbff").pack(
                side="left", padx=(18, 12))
        brand = tk.Frame(top, bg="#f3fbff"); brand.pack(side="left", anchor="n")
        tk.Label(brand, text="Every Link Counts,", font=("Helvetica", 13, "italic"), fg="#1b5f73", bg="#f3fbff").pack(anchor="w")
        tk.Label(brand, text="Every Route Matters", font=("Helvetica", 16, "bold"), fg="#e85a4f", bg="#f3fbff").pack(anchor="w")
        tk.Label(self, text="A student-first travel connection platform for VIT students â€” plan, match, and share journeys.",
                 font=("Arial", 10), bg="#f3fbff", fg="#333").pack(pady=2)
        ttk.Separator(self, orient="horizontal").pack(fill="x", pady=6)

        # notebook
        style = ttk.Style(self)
        try:
            style.theme_use('clam')
        except Exception:
            pass
        style.configure("TNotebook.Tab", font=("Helvetica", 11, "bold"))
        self.nb = ttk.Notebook(self); self.nb.pack(fill="both", expand=True, padx=12, pady=8)

        # initial tab
        self.start_tab = StartTab(self.nb, app=self)
        self.nb.add(self.start_tab, text="Get Started")

        # placeholders
        self.calendar_tab = None
        self.route_tab = None
        self.link_tab = None

        # holidays
        self.holidays = load_academic_holidays()

    # DB helper: count how many joined links for route on date
    def get_join_count(self, iso_date: str, route_id: int) -> int:
        try:
            conn = sqlite3.connect(DB)
            c = conn.cursor()
            c.execute("SELECT COUNT(*) FROM calendar WHERE travel_date=? AND route_id=? AND link_id IS NOT NULL", (iso_date, route_id))
            r = c.fetchone()
            conn.close()
            return int(r[0]) if r else 0
        except Exception:
            return 0

    # used for mini calendar: number of distinct routes on day
    def get_route_count_for_day(self, iso_date: str) -> int:
        try:
            conn = sqlite3.connect(DB)
            c = conn.cursor()
            c.execute("SELECT COUNT(DISTINCT route_id) FROM calendar WHERE travel_date=?", (iso_date,))
            r = c.fetchone()
            conn.close()
            return int(r[0]) if r else 0
        except Exception:
            return 0

    def get_route_summary(self, iso_date: str) -> str:
        try:
            conn = sqlite3.connect(DB)
            c = conn.cursor()
            c.execute("""
                SELECT DISTINCT r.id, r.slot_no, r.end_point, r.time
                FROM calendar cal
                LEFT JOIN routes r ON cal.route_id = r.id
                WHERE cal.travel_date = ?
                ORDER BY r.id
            """, (iso_date,))
            rows = c.fetchall()
            conn.close()
            if not rows:
                return "No scheduled routes"
            lines = []
            for i, (rid, slot, endp, t) in enumerate(rows, start=1):
                tdisp = t or "-"
                lines.append(f"{i}) {slot} â†’ {endp} @ {tdisp} (RouteID:{rid})")
            return "\n".join(lines)
        except Exception:
            return "Unable to load routes"

    # check if date is in the past
    def is_past_date(self, iso_date: str) -> bool:
        try:
            sel = datetime.strptime(iso_date, "%Y-%m-%d").date()
            return sel < date.today()
        except Exception:
            return False

    # tab flow
    def show_calendar_tab(self):
        for t in list(self.nb.tabs()):
            self.nb.forget(t)
        self.calendar_tab = CalendarTab(self.nb, app=self, holidays=self.holidays,
                                        get_counts=self.get_route_count_for_day,
                                        get_summary=self.get_route_summary)
        self.nb.add(self.calendar_tab, text="Calendar")
        self.nb.select(self.calendar_tab)

    def show_route_tab(self, iso_date: str):
        # check past date â€” do not allow opening route tab for past dates
        if self.is_past_date(iso_date):
            messagebox.showwarning("Date passed", f"{iso_date} has already passed. Please select today or a future date.")
            return
        if self.route_tab is None:
            self.route_tab = RouteTab(self.nb, app=self)
            self.nb.add(self.route_tab, text="Route Details")
        self.route_tab.set_current_date(iso_date)
        self.nb.select(self.route_tab)

    def show_link_tab(self, route_id: int, route_date: str):
        if self.link_tab is None:
            self.link_tab = LinkTab(self.nb, app=self)
            self.nb.add(self.link_tab, text="Link Details")
        self.link_tab.prefill_for_route(route_id, route_date)
        self.nb.select(self.link_tab)


# ---------------- StartTab ----------------
class StartTab(ttk.Frame):
    def __init__(self, parent, app):
        super().__init__(parent, padding=18)
        self.app = app

        # make content scrollable
        scroll = ScrollableFrame(self, width=880, height=520)
        scroll.pack(fill="both", expand=True, padx=6, pady=6)
        container = scroll.inner

        tk.Label(container, text="Welcome to RouteLink", font=("Georgia", 22, "bold"), fg="#0b5878").pack(pady=(12, 6))
        tk.Label(container, text="Register with your VIT email, then login to continue", font=("Arial", 11), fg="#444").pack(pady=(0, 12))

        btn_frame = tk.Frame(container)
        btn_frame.pack(pady=18)
        tk.Button(btn_frame, text="Register", command=self.open_register, width=18, bg="#2a9d8f", fg="white").grid(row=0, column=0, padx=12, pady=4)
        tk.Button(btn_frame, text="Login", command=self.open_login, width=18, bg="#e76f51", fg="white").grid(row=0, column=1, padx=12, pady=4)

        tk.Label(container, text="Tip: Register first. After login you'll see the Calendar where you can add routes.", fg="#666").pack(pady=10)

    def open_register(self):
        RegisterDialog(self.app)

    def open_login(self):
        LoginDialog(self.app)


# ---------------- Register / Login ----------------
class RegisterDialog(tk.Toplevel):
    def __init__(self, app):
        super().__init__(app)
        self.title("Register - RouteLink")
        self.geometry("520x520")
        self.resizable(True, True)
        self.grab_set()

        # Scrollable content
        scroll = ScrollableFrame(self, width=480, height=420)
        scroll.pack(fill="both", expand=True, padx=8, pady=8)
        frame = scroll.inner

        tk.Label(frame, text="Create an account", font=("Helvetica", 14, "bold")).grid(row=0, column=0, columnspan=2, pady=(4, 12))

        tk.Label(frame, text="Full Name").grid(row=1, column=0, sticky="w", pady=6)
        self.name = tk.Entry(frame, width=36); self.name.grid(row=1, column=1, pady=6)
        tk.Label(frame, text="Email (VIT only)").grid(row=2, column=0, sticky="w", pady=6)
        self.email = tk.Entry(frame, width=36); self.email.grid(row=2, column=1, pady=6)
        tk.Label(frame, text="Password").grid(row=3, column=0, sticky="w", pady=6)
        self.pw = tk.Entry(frame, width=36, show="*"); self.pw.grid(row=3, column=1, pady=6)

        # Gender selection (M/F) added to registration
        tk.Label(frame, text="Gender").grid(row=4, column=0, sticky="w", pady=6)
        self.gender_var = tk.StringVar(value="M")
        gframe = tk.Frame(frame)
        gframe.grid(row=4, column=1, sticky="w", pady=6)
        tk.Radiobutton(gframe, text="Male", variable=self.gender_var, value="M").pack(side="left", padx=4)
        tk.Radiobutton(gframe, text="Female", variable=self.gender_var, value="F").pack(side="left", padx=4)

        tk.Button(frame, text="Register", bg="#2a9d8f", fg="white", width=20, command=self.do_register).grid(row=6, column=0, columnspan=2, pady=12)

    def do_register(self):
        name = self.name.get().strip()
        email = self.email.get().strip().lower()
        pw = self.pw.get()
        gender = (self.gender_var.get() or "").strip().upper()
        if not name or not email or not pw or gender not in ("M", "F"):
            messagebox.showerror("Validation", "All fields required (including gender).")
            return
        if not re.match(r"^[A-Za-z0-9._%+-]+@vitstudent\.ac\.in$", email):
            messagebox.showerror("Validation", "Please use a VIT email (example@vitstudent.ac.in).")
            return

        try:
            conn = sqlite3.connect(DB)
            c = conn.cursor()
            # users table may or may not have gender column depending on older DB; migration added it earlier
            c.execute("INSERT INTO users (name, email, password_hash, gender) VALUES (?, ?, ?, ?)", (name, email, hash_pw(pw), gender))
            conn.commit()
            conn.close()
            messagebox.showinfo("Success", "Registration completed. Now login.")
            self.destroy()
        except sqlite3.IntegrityError:
            messagebox.showerror("Error", "Email already registered.")
        except Exception as e:
            # fallback if migration didn't run: try without gender column
            try:
                conn = sqlite3.connect(DB)
                c = conn.cursor()
                c.execute("INSERT INTO users (name, email, password_hash) VALUES (?, ?, ?)", (name, email, hash_pw(pw)))
                conn.commit()
                conn.close()
                messagebox.showinfo("Success", "Registration completed. Now login.")
                self.destroy()
            except Exception:
                messagebox.showerror("Error", "Unable to register. Please try again.")


class LoginDialog(tk.Toplevel):
    def __init__(self, app):
        super().__init__(app)
        self.app = app
        self.title("Login - RouteLink")
        self.geometry("480x360")
        self.resizable(True, True)
        self.grab_set()

        scroll = ScrollableFrame(self, width=440, height=300)
        scroll.pack(fill="both", expand=True, padx=8, pady=8)
        frame = scroll.inner

        tk.Label(frame, text="Login", font=("Helvetica", 14, "bold")).grid(row=0, column=0, columnspan=2, pady=(4, 12))

        tk.Label(frame, text="Email").grid(row=1, column=0, sticky="w", pady=6)
        self.email = tk.Entry(frame, width=36); self.email.grid(row=1, column=1, pady=6)
        tk.Label(frame, text="Password").grid(row=2, column=0, sticky="w", pady=6)
        self.pw = tk.Entry(frame, width=36, show="*"); self.pw.grid(row=2, column=1, pady=6)

        tk.Button(frame, text="Login", bg="#e76f51", fg="white", width=20, command=self.do_login).grid(row=3, column=0, columnspan=2, pady=12)

    def do_login(self):
        email = self.email.get().strip().lower()
        pw = self.pw.get()
        if not email or not pw:
            messagebox.showerror("Validation", "Enter email and password.")
            return
        if not user_exists(email):
            messagebox.showerror("No account", "No account found with this email. Please register first.")
            return
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("SELECT id, name FROM users WHERE email=? AND password_hash=?", (email, hash_pw(pw)))
        r = c.fetchone()
        conn.close()
        if r:
            messagebox.showinfo("Welcome", f"Hello, {r[1]}! Entering the app.")
            self.destroy()
            self.app.show_calendar_tab()
        else:
            messagebox.showerror("Error", "Invalid credentials. If you don't have an account, please register.")


# ---------------- Calendar Tab ----------------
class CalendarTab(ttk.Frame):
    def __init__(self, parent, app, holidays=None, get_counts=None, get_summary=None):
        super().__init__(parent, padding=14)
        self.app = app
        self.holidays = set(holidays or [])
        self.get_counts = get_counts
        self.get_summary = get_summary

        # whole tab scrollable
        scroll = ScrollableFrame(self, width=920, height=620)
        scroll.pack(fill="both", expand=True, padx=6, pady=6)
        container = scroll.inner

        tk.Label(container, text="ðŸ“… Calendar", font=("Georgia", 20, "bold"), fg="#0b5878").pack(pady=(6, 4))
        tk.Label(container, text="Hover a day to see route summaries. Click a date to open Route Details.", font=("Arial", 10), fg="#444").pack(pady=(0, 8))

        container2 = tk.Frame(container)
        container2.pack(fill="both", expand=True, padx=8, pady=6)

        left = tk.Frame(container2, bd=0, padx=8, pady=8)
        left.pack(side="left", padx=6, pady=6)
        right = tk.Frame(container2, padx=8, pady=8)
        right.pack(side="left", fill="both", expand=True, padx=6, pady=6)

        self.mini = MiniCalendar(left, on_select=self.on_mini_select, holidays=self.holidays,
                                get_counts=self.get_counts, get_summary=self.get_summary)
        self.mini.pack()

        tk.Label(right, text="Holidays", font=("Arial", 12, "bold")).pack(anchor="nw")
        self.hol_text = tk.Text(right, height=6, width=40)
        self.hol_text.pack(pady=6)
        self._populate_holidays()

        tk.Label(right, text="Routes for selected date", font=("Arial", 12, "bold")).pack(anchor="nw")
        self.routes_text = tk.Text(right, height=12)
        self.routes_text.pack(fill="both", expand=True, pady=6)
        self.routes_text.config(state='disabled')

        self.current_date = date.today().isoformat()
        self.display_routes_for_date(self.current_date)

    def _populate_holidays(self):
        self.hol_text.delete("1.0", tk.END)
        if not self.holidays:
            self.hol_text.insert(tk.END, "No holiday data available.\n")
            return
        for h in sorted(self.holidays):
            try:
                pretty = datetime.strptime(h, "%Y-%m-%d").strftime("%d %b %Y")
            except Exception:
                pretty = h
            self.hol_text.insert(tk.END, f"â€¢ {pretty}\n")
        self.hol_text.config(state='disabled')

    def on_mini_select(self, iso_date):
        # Block past dates with clearer message
        if self.app.is_past_date(iso_date):
            messagebox.showwarning("Invalid Date", f"{iso_date} has already passed. Please select today or a future date.")
            return
        self.current_date = iso_date
        self.display_routes_for_date(iso_date)
        self.app.show_route_tab(iso_date)

    def display_routes_for_date(self, iso_date):
        self.routes_text.delete("1.0", tk.END)
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("""
            SELECT DISTINCT r.id, r.slot_no, r.end_point, r.time, r.transport_type
            FROM calendar cal
            LEFT JOIN routes r ON cal.route_id = r.id
            WHERE cal.travel_date = ?
            ORDER BY r.id DESC
        """, (iso_date,))
        rows = c.fetchall()
        conn.close()
        if not rows:
            self.routes_text.insert(tk.END, f"No routes on {iso_date}\n\nClick the date to add one.\n")
            return
        self.routes_text.insert(tk.END, f"Routes on {iso_date}:\n\n")
        for r_id, slot, endp, ttime, ttype in rows:
            self.routes_text.insert(tk.END, f"- {slot} â†’ {endp} | {ttime or '-'} | {ttype or '-'} (RouteID:{r_id})\n")


# ---------------- Route Tab ----------------
class RouteTab(ttk.Frame):
    def __init__(self, parent, app):
        super().__init__(parent, padding=14)
        self.app = app
        self.current_date = None

        scroll = ScrollableFrame(self, width=920, height=620)
        scroll.pack(fill="both", expand=True, padx=6, pady=6)
        container = scroll.inner

        tk.Label(container, text="ðŸšŒ Route Details", font=("Georgia", 20, "bold"), fg="#0b5878").pack(pady=(6, 4))
        tk.Label(container, text="Double-click a row to open Link Details for that route (join people there).", font=("Arial", 10), fg="#444").pack(pady=(0, 8))

        cols = ("Slot No", "End Point", "Major Stops", "Time", "Transport", "Count")
        self.tree = ttk.Treeview(container, columns=cols, show="headings", height=12)
        for c in cols:
            self.tree.heading(c, text=c)
            if c == "Major Stops":
                self.tree.column(c, width=260)
            elif c == "End Point":
                self.tree.column(c, width=160)
            elif c == "Count":
                self.tree.column(c, width=80, anchor="center")
            else:
                self.tree.column(c, width=110)
        self.tree.pack(fill="both", expand=True, padx=8, pady=8)
        self.tree.bind("<Double-1>", self.on_route_double_click)

        btn_frame = tk.Frame(container)
        btn_frame.pack(pady=6)
        tk.Button(btn_frame, text="âž• Add Route", bg="#2a9d8f", fg="white", command=self.add_route).pack(side="left", padx=8)

    def set_current_date(self, iso_date: str):
        self.current_date = iso_date
        self.refresh()

    def add_route(self):
        if not self.current_date:
            messagebox.showerror("Error", "No date selected.")
            return
        RouteDialog(self.app, pre_fill_date=self.current_date, after_create_callback=self._after_route_created)

    def _after_route_created(self, route_id, route_date):
        self.refresh()
        if self.app.calendar_tab and hasattr(self.app.calendar_tab, "mini"):
            try:
                self.app.calendar_tab.mini.update_counts_source(self.app.get_route_count_for_day)
            except Exception:
                pass
        # Removed the "Route created" messagebox as requested.

    def refresh(self):
        for r in self.tree.get_children():
            self.tree.delete(r)
        if not self.current_date:
            return
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("""
            SELECT DISTINCT r.id, r.slot_no, r.end_point, r.major_stops, r.time, r.transport_type
            FROM routes r
            JOIN calendar cal ON cal.route_id = r.id
            WHERE cal.travel_date = ?
            ORDER BY r.id DESC
        """, (self.current_date,))
        rows = c.fetchall()
        conn.close()
        for row in rows:
            rid, slot, endp, stops, ttime, ttype = row
            count = self.app.get_join_count(self.current_date, rid)
            self.tree.insert("", "end", iid=str(rid), values=(slot, endp, stops, ttime or "-", ttype or "-", str(count)))

    def on_route_double_click(self, event):
        item = self.tree.identify_row(event.y)
        if not item:
            return
        try:
            route_id = int(item)  # used route id as iid
        except Exception:
            return
        # protect against past date
        if self.app.is_past_date(self.current_date):
            messagebox.showwarning("Date passed", f"{self.current_date} has already passed. Please select today or a future date.")
            return
        # open Link tab for selecting/joining links (no informational popup)
        self.app.show_link_tab(route_id, self.current_date)


# ---------------- Route Dialog (slot autogen) ----------------
class RouteDialog(tk.Toplevel):
    def __init__(self, app, pre_fill_date=None, after_create_callback=None):
        super().__init__(app)
        self.app = app
        self.after_create_callback = after_create_callback
        self.title("Create Route")
        self.geometry("640x520")
        self.resizable(True, True)
        self.grab_set()

        scroll = ScrollableFrame(self, width=600, height=440)
        scroll.pack(fill="both", expand=True, padx=8, pady=8)
        frame = scroll.inner
        frame.config(bg="#f8ffff")

        tk.Label(frame, text="Create Route for Date", font=("Helvetica", 12, "bold"), bg="#f8ffff").grid(row=0, column=0, columnspan=2, pady=(0, 8))
        tk.Label(frame, text="Date (YYYY-MM-DD)", bg="#f8ffff").grid(row=1, column=0, sticky="w", pady=6)
        self.date_ent = tk.Entry(frame, width=20); self.date_ent.grid(row=1, column=1, pady=6)
        if pre_fill_date:
            self.date_ent.insert(0, pre_fill_date)

        # Labels; Slot No will be autogenerated and pre-filled
        labels = ["Slot No", "End Point", "Major Stops", "Time (HH:MM)", "Transport Type"]
        self.entries = {}
        for i, lab in enumerate(labels, start=2):
            tk.Label(frame, text=lab, bg="#f8ffff").grid(row=i, column=0, sticky="w", pady=6)
            ent = tk.Entry(frame, width=44); ent.grid(row=i, column=1, pady=6)
            self.entries[lab] = ent

        # Autogenerate slot and put into Slot No by default
        try:
            generated = generate_next_slot_no()
        except Exception:
            generated = "SL0000"
        self.entries["Slot No"].insert(0, generated)

        tk.Button(frame, text="Create Route", bg="#2a9d8f", fg="white", width=18, command=self.create_route).grid(row=8, column=0, columnspan=2, pady=12)

    def create_route(self):
        d = self.date_ent.get().strip()
        try:
            datetime.strptime(d, "%Y-%m-%d")
        except Exception:
            messagebox.showerror("Validation", "Date must be YYYY-MM-DD.")
            return
        vals = [self.entries[k].get().strip() for k in self.entries]
        if not all(vals):
            messagebox.showerror("Validation", "All route fields are required.")
            return
        t = vals[3]
        if t:
            try:
                datetime.strptime(t, "%H:%M")
            except Exception:
                messagebox.showerror("Validation", "Time must be HH:MM.")
                return

        # Duplicate check: same transport, endpoint, time for date
        try:
            conn = sqlite3.connect(DB)
            c = conn.cursor()
            c.execute("""
                SELECT r.id
                FROM routes r
                JOIN calendar cal ON cal.route_id = r.id
                WHERE cal.travel_date = ?
                  AND LOWER(r.end_point) = LOWER(?)
                  AND COALESCE(r.time, '') = ?
                  AND LOWER(COALESCE(r.transport_type, '')) = LOWER(?)
                LIMIT 1
            """, (d, vals[1], vals[3], vals[4]))
            existing = c.fetchone()
            conn.close()
            if existing:
                messagebox.showwarning("Duplicate Route",
                                       "A route with the same endpoint, time and transport already exists for the selected date.\n\n"
                                       "Please check the Route Details for that date before creating a duplicate.")
                return
        except Exception:
            # If DB check fails, continue but ideally log
            pass

        # Insert route + calendar mapping
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("INSERT INTO routes (slot_no, end_point, major_stops, time, transport_type, no_of_people) VALUES (?, ?, ?, ?, ?, ?)",
                  (vals[0], vals[1], vals[2], vals[3], vals[4], 0))
        conn.commit()
        route_id = c.lastrowid
        c.execute("INSERT INTO calendar (travel_date, route_id, link_id) VALUES (?, ?, NULL)", (d, route_id))
        conn.commit()
        conn.close()

        if callable(self.after_create_callback):
            # callback handles UI refresh; we intentionally do not show a messagebox here
            self.after_create_callback(route_id, d)
        self.destroy()


# ---------------- Link Tab (ID column hidden, gender filter) ----------------
class LinkTab(ttk.Frame):
    def __init__(self, parent, app):
        super().__init__(parent, padding=14)
        self.app = app
        self.route_id = None
        self.route_date = None
        self.route_end_point = None

        # scrollable
        scroll = ScrollableFrame(self, width=920, height=620)
        scroll.pack(fill="both", expand=True, padx=6, pady=6)
        container = scroll.inner

        tk.Label(container, text="ðŸ‘¥ Link Details (Join Route)", font=("Georgia", 20, "bold"), fg="#0b5878").pack(pady=(6, 4))
        tk.Label(container, text="Enter your details and click 'Join Route' to register yourself for the selected route/date.", font=("Arial", 10), fg="#444").pack(pady=(0, 8))

        # filter bar
        fbar = tk.Frame(container)
        fbar.pack(fill="x", padx=8, pady=(0,6))
        tk.Label(fbar, text="Filter by gender:").pack(side="left")
        self.gender_filter = ttk.Combobox(fbar, values=["All", "Male", "Female"], width=10, state="readonly")
        self.gender_filter.set("All")
        self.gender_filter.pack(side="left", padx=(6,12))
        self.gender_filter.bind("<<ComboboxSelected>>", lambda e: self._on_filter_change())

        frame = tk.Frame(container)
        frame.pack(pady=6, fill="x")
        # We'll create Drop as an Entry that can be toggled to readonly when prefilled for a route.
        labels = ["Name", "Gender", "Drop", "Phone", "Course Year", "Branch"]
        self.entries = {}
        for i, lab in enumerate(labels):
            tk.Label(frame, text=lab).grid(row=i, column=0, sticky="w", padx=6, pady=4)
            if lab == "Gender":
                gb = tk.Frame(frame)
                gb.grid(row=i, column=1, padx=6, pady=4, sticky="w")
                self.gender_var = tk.StringVar(value="M")
                tk.Radiobutton(gb, text="M", variable=self.gender_var, value="M").pack(side="left", padx=6)
                tk.Radiobutton(gb, text="F", variable=self.gender_var, value="F").pack(side="left", padx=6)
                # store an entry-like object for consistent access; use a small hidden Entry to read/write like others
                e = tk.Entry(frame, width=36)
                e.grid_forget()
                self.entries[lab] = e
            else:
                e = tk.Entry(frame, width=36)
                e.grid(row=i, column=1, padx=6, pady=4)
                self.entries[lab] = e

        btn_frame = tk.Frame(frame)
        btn_frame.grid(row=len(labels), column=0, columnspan=2, pady=8)
        tk.Button(btn_frame, text="Join Route", bg="#2a9d8f", fg="white", command=self.join_route).pack(side="left", padx=6)
        self.delete_link_btn = tk.Button(btn_frame, text="Delete Selected Link(s)", bg="#d9534f", fg="white", command=self.delete_selected_link, state="disabled")
        self.delete_link_btn.pack(side="left", padx=6)

        # No ID column shown. Visible columns:
        cols = ("Name", "Gender", "Drop", "Phone", "Year", "Branch")
        self.tree = ttk.Treeview(container, columns=cols, show="headings", height=10, selectmode="extended")
        for c in cols:
            self.tree.heading(c, text=c)
            self.tree.column(c, width=120)
        self.tree.pack(fill="both", expand=True, padx=8, pady=8)
        self.tree.bind("<<TreeviewSelect>>", self.on_tree_select)

        self.refresh()

    def _on_filter_change(self):
        # When filter changes, refresh current view (route-specific or general)
        if self.route_id and self.route_date:
            self.refresh_for_route()
        else:
            self.refresh()

    def prefill_for_route(self, route_id: int, route_date: str):
        """
        When opened for a specific route:
         - set route_id, route_date
         - fetch route end_point
         - set the Drop entry to that end_point and make it readonly (so user cannot type a different value)
         - refresh the tree to show links joined for that route/date only
        """
        self.route_id = route_id
        self.route_date = route_date
        # fetch route end_point for validation
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("SELECT end_point FROM routes WHERE id=?", (route_id,))
        r = c.fetchone()
        conn.close()
        self.route_end_point = r[0] if r else None

        # set Drop entry to route_end_point and make readonly
        drop_entry = self.entries.get("Drop")
        if drop_entry:
            try:
                drop_entry.config(state="normal")
            except Exception:
                pass
            drop_entry.delete(0, tk.END)
            if self.route_end_point:
                drop_entry.insert(0, self.route_end_point)
                # make readonly so user can't type a different location
                try:
                    drop_entry.config(state="readonly")
                except Exception:
                    pass
            else:
                # if no known endpoint, leave editable
                try:
                    drop_entry.config(state="normal")
                except Exception:
                    pass

        self.delete_link_btn.config(state="disabled")
        self.refresh_for_route()
        # No informational messagebox (per your preferences)

    def refresh(self):
        """Show all links (default) â€” uses iid 'link_<id>' but hides id column."""
        for r in self.tree.get_children():
            self.tree.delete(r)
        gender_sel = self.gender_filter.get()
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("SELECT id, name, gender, drop_point, phone, course_year, branch FROM links ORDER BY id DESC")
        for row in c.fetchall():
            lid, name, gender, drop, phone, year, branch = row
            # normalize gender
            gender = (gender or "").upper()
            if gender_sel == "Male" and gender != "M":
                continue
            if gender_sel == "Female" and gender != "F":
                continue
            iid = f"link_{lid}"
            self.tree.insert("", "end", iid=iid, values=(name, gender or "-", drop or "-", phone or "-", year or "-", branch or "-"))
        conn.close()
        self.delete_link_btn.config(state="disabled")
        # Ensure Drop entry editable when browsing general link list
        drop_entry = self.entries.get("Drop")
        if drop_entry:
            try:
                drop_entry.config(state="normal")
            except Exception:
                pass

    def refresh_for_route(self):
        """Show only links attached to current route & date, iids still encode link id."""
        for r in self.tree.get_children():
            self.tree.delete(r)
        if not self.route_id or not self.route_date:
            self.refresh()
            return
        gender_sel = self.gender_filter.get()
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("""
            SELECT l.id, l.name, l.gender, l.drop_point, l.phone, l.course_year, l.branch
            FROM links l
            JOIN calendar cal ON cal.link_id = l.id
            WHERE cal.route_id = ? AND cal.travel_date = ?
            ORDER BY l.id DESC
        """, (self.route_id, self.route_date))
        rows = c.fetchall()
        conn.close()
        for row in rows:
            lid, name, gender, drop, phone, year, branch = row
            gender = (gender or "").upper()
            if gender_sel == "Male" and gender != "M":
                continue
            if gender_sel == "Female" and gender != "F":
                continue
            iid = f"link_{lid}"
            self.tree.insert("", "end", iid=iid, values=(name, gender or "-", drop or "-", phone or "-", year or "-", branch or "-"))
        self.delete_link_btn.config(state="disabled")

    def on_tree_select(self, event):
        sel = self.tree.selection()
        if sel:
            self.delete_link_btn.config(state="normal")
        else:
            self.delete_link_btn.config(state="disabled")

    def join_route(self):
        if not self.route_id or not self.route_date:
            messagebox.showerror("Error", "No route selected.")
            return
        # read entries; Gender comes from self.gender_var
        vals = []
        # Name
        vals.append(self.entries["Name"].get().strip())
        # Gender
        gender = (self.gender_var.get() or "").strip().upper()
        vals.append(gender)
        # Drop
        vals.append(self.entries["Drop"].get().strip())
        # Phone
        vals.append(self.entries["Phone"].get().strip())
        # Course Year
        vals.append(self.entries["Course Year"].get().strip())
        # Branch
        vals.append(self.entries["Branch"].get().strip())

        if not all(vals):
            messagebox.showerror("Validation", "All fields required to join.")
            return
        phone = vals[3]
        drop = vals[2]
        if gender not in ("M", "F"):
            messagebox.showerror("Validation", "Select gender (M or F).")
            return
        if not phone.isdigit() or len(phone) < 7:
            messagebox.showerror("Validation", "Phone must be digits and at least 7 digits.")
            return
        # enforce drop matches route end_point (redundant if readonly, but double-check)
        if self.route_end_point and drop.strip().lower() != self.route_end_point.strip().lower():
            messagebox.showerror("Mismatch", f"Drop/location must match route destination: '{self.route_end_point}'.\nPlease use the same destination.")
            return
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        # Prevent duplicate for same phone + route + date
        c.execute("SELECT l.id FROM links l JOIN calendar cal ON cal.link_id = l.id WHERE cal.travel_date=? AND cal.route_id=? AND l.phone=?", (self.route_date, self.route_id, phone))
        if c.fetchone():
            conn.close()
            messagebox.showerror("Already joined", "This phone has already joined this route on that date.")
            return
        # insert link (including gender)
        try:
            c.execute("INSERT INTO links (name, gender, drop_point, phone, course_year, branch) VALUES (?, ?, ?, ?, ?, ?)", (vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]))
        except Exception:
            # fallback if migration somehow didn't happen
            c.execute("INSERT INTO links (name, drop_point, phone, course_year, branch) VALUES (?, ?, ?, ?, ?)", (vals[0], vals[2], vals[3], vals[4], vals[5]))
        link_id = c.lastrowid
        # link to calendar
        c.execute("INSERT INTO calendar (travel_date, route_id, link_id) VALUES (?, ?, ?)", (self.route_date, self.route_id, link_id))
        conn.commit()
        conn.close()
        # No join-success popup (quiet)
        # clear inputs but keep Drop readonly if route-specific
        for k,e in self.entries.items():
            if k == "Gender":
                self.gender_var.set("M")
                continue
            try:
                e.config(state="normal")
                e.delete(0, tk.END)
            except Exception:
                pass
        if self.route_end_point:
            drop_entry = self.entries.get("Drop")
            if drop_entry:
                drop_entry.insert(0, self.route_end_point)
                try:
                    drop_entry.config(state="readonly")
                except Exception:
                    pass

        self.refresh_for_route()
        # update route table count and calendar badges
        if self.app.route_tab:
            self.app.route_tab.refresh()
        if self.app.calendar_tab and hasattr(self.app.calendar_tab, "mini"):
            try:
                self.app.calendar_tab.mini.update_counts_source(self.app.get_route_count_for_day)
            except Exception:
                pass
        if self.app.calendar_tab:
            try:
                self.app.calendar_tab.display_routes_for_date(self.route_date)
            except Exception:
                pass

    def delete_selected_link(self):
        """Delete selected link(s) and related calendar entries. Uses item iids 'link_<id>'."""
        sel = self.tree.selection()
        if not sel:
            messagebox.showerror("Select", "Select one or more link rows to delete.")
            return
        link_ids = []
        for iid in sel:
            # iid expected to be 'link_<id>'
            if isinstance(iid, str) and iid.startswith("link_"):
                try:
                    link_ids.append(int(iid.split("_", 1)[1]))
                except Exception:
                    pass
        if not link_ids:
            messagebox.showerror("Error", "Couldn't determine selected link ids.")
            return
        if not messagebox.askyesno("Confirm", f"Delete {len(link_ids)} selected link(s)? This will remove them from the app and any calendar mappings."):
            return
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.executemany("DELETE FROM calendar WHERE link_id=?", [(lid,) for lid in link_ids])
        c.executemany("DELETE FROM links WHERE id=?", [(lid,) for lid in link_ids])
        conn.commit()
        conn.close()
        messagebox.showinfo("Deleted", f"Deleted {len(link_ids)} link(s).")
        if self.route_id and self.route_date:
            self.refresh_for_route()
        else:
            self.refresh()
        if self.app.route_tab:
            self.app.route_tab.refresh()
        if self.app.calendar_tab and hasattr(self.app.calendar_tab, "mini"):
            try:
                self.app.calendar_tab.mini.update_counts_source(self.app.get_route_count_for_day)
            except Exception:
                pass
        if self.app.calendar_tab:
            try:
                self.app.calendar_tab.display_routes_for_date(date.today().isoformat())
            except Exception:
                pass
        self.delete_link_btn.config(state="disabled")


# ---------------- Run ----------------
if __name__ == "__main__":
    init_db()
    app = RouteLinkApp()
    app.mainloop()
